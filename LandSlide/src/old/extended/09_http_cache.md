# HTTP Cache

---

# HTTP Cache

The nature of rich web applications means that they're dynamic. No matter how
efficient your application, **each request will always contain more overhead
than serving a static file**.

But as your site grows, that overhead can become a problem. The processing
that's normally performed on every request should be done only once.

This is exactly what **caching** aims to accomplish!

---

# Terminology (1/2)

### Gateway Cache

A **gateway cache**, or **reverse proxy**, is an independent layer that sits in
front of your application.

The **reverse proxy** caches responses as they are returned from your application
and answers requests with cached responses before they hit your application.

Symfony provides its own reverse proxy, but any reverse proxy can be used.

### HTTP Cache

**HTTP cache headers** are used to communicate with the gateway cache and any
other caches between your application and the client.

Symfony provides sensible defaults and a powerful interface for interacting
with the cache headers.

---

# Terminology (2/2)

### HTTP Expiration

**HTTP expiration** and **validation** are the two models used for determining
whether cached content is fresh (can be reused from the cache) or stale (should
be regenerated by the application).

### Edge Side Includes

**Edge Side Includes** (ESI) allow HTTP cache to be used to **cache page
fragments** (even nested fragments) independently. With ESI, you can even cache
an entire page for 60 minutes, but an embedded sidebar for only 5 minutes.

---

# Caching with a Gateway Cache

When caching with HTTP, the **cache is separated from your application** entirely
and sits **between your application and the client** making the request.

The job of the cache is to **accept requests from the client and pass them back
to your application**.

The cache will also receive responses back from your application and forward
them on to the client. The cache is the **middle-man** of the request-response
communication between the client and your application.

Along the way, the cache will store each response that is deemed **cacheable**.
If the same resource is requested again, the cache sends the cached response to
the client, ignoring your application entirely.

This type of cache is known as a **HTTP gateway cache** and many exist such as
**Varnish**, **Squid** in reverse proxy mode, and the **Symfony reverse
proxy**.

---

# Types of Caches

The HTTP cache headers sent by your application are consumed and interpreted by
up to three different types of caches:

* **Browser Caches**: every browser comes with its own local cache that is mainly
useful for when you hit "back" or for images and other assets. The browser cache
is a **private cache** as cached resources aren't shared with anyone else;
* **Proxy Caches**: a proxy is a shared cache as many people can be behind a
single one. It's usually installed by large corporations and ISPs to reduce
latency and network traffic;
* **Gateway Caches**: like a **proxy**, it's also a shared cache but on the
server side. Installed by network administrators, it makes websites more
scalable, reliable and performant.

---

#Â HTTP Caching

HTTP specifies four response cache headers that are looked at here:

* `Cache-Control`
* `Expires`
* `ETag`
* `Last-Modified`

---

# Public vs Private Responses

Both **gateway and proxy caches are considered shared caches** as the cached
content is shared by more than one user.

If a user-specific response were ever mistakenly stored by a shared cache, it
might be returned later to any number of different users. Imagine if your
account information were cached and then returned to every subsequent user who
asked for their account page!

To handle this situation, every response may be set to be public or private:

* **public**: indicates that the response may be cached by both private and
shared caches;
* **private**: indicates that all or part of the response message is intended for
a single user and must not be cached by a shared cache.

---

# Safe Methods

**HTTP caching only works for safe HTTP methods** (like `GET` and `HEAD`). Being
safe means that **you never change the application's state on the server when
serving the request**.

This has two very reasonable consequences:

* You should **never change the state of your application when responding to a
`GET` or `HEAD` request**. Even if you don't use a gateway cache, the presence
of proxy caches mean that any `GET` or `HEAD` request may or may not actually
hit your server;
* Don't expect `PUT`, `POST` or `DELETE` methods to cache. These methods are
meant to be used when **mutating the state of your application**. Caching them
would prevent certain requests from hitting and mutating your application.

---

# Expiration

The expiration model is the more efficient and straightforward of the two
caching models and should be used whenever possible.

When a response is cached with an expiration, the cache will store the response
and return it directly without hitting the application until it expires.

The expiration model can be accomplished using one of two HTTP headers:

* `Cache-Control`
* `Expires`

---

# The Cache-Control Header (1/2)

The `Cache-Control` header is **unique** in that it contains not one, but
various pieces of information about the cacheability of a response.

Each piece of information is separated by a comma:

    !text
    Cache-Control: private, max-age=0, must-revalidate
    Cache-Control: max-age=3600, must-revalidate

---

# The Cache-Control Header (2/2)

Symfony provides an **abstraction** around the `Cache-Control` header:

    !php
    use Symfony\Component\HttpFoundation\Response;

    $response = new Response();

    // mark the response as either public or private
    $response->setPublic();
    $response->setPrivate();

    // set the private or shared max age
    $response->setMaxAge(600);
    $response->setSharedMaxAge(600);

    // set a custom Cache-Control directive
    $response->headers->addCacheControlDirective('must-revalidate', true);

---

# The Expires Header

The `Expires` header can be set with the `setExpires()` Response method. It takes
a `DateTime` instance as an argument:

    !php
    $date = new DateTime();
    $date->modify('+600 seconds');

    $response->setExpires($date);

The resulting HTTP header will look like this:

    !text
    Expires: Thu, 01 Mar 2013 10:00:00 GMT

The `setExpires()` method automatically converts the date to the GMT timezone as
required by the specification.

---

# Validation

With the expiration model, the application won't be asked to return the updated
response until the cache finally becomes stale. It is not good!

The validation model addresses this issue.

Under this model, the cache continues to store responses. The difference is
that, for each request, the **cache asks the application whether or not the
cached response is still valid**.

If the cache is still valid, your application should return a `304` status code
and no content. This tells the cache that it's ok to return the cached response.

---

# The ETag Header

The `ETag` header is a **string header** called **entity-tag** that uniquely
**identifies one representation of the target resource**. It's entirely
**generated and set by your application**.

`ETag`s are similar to **fingerprints** and they can be quickly compared to
determine if two versions of a resource are the same or not.

    !php
    public function indexAction()
    {
        $response = $this->render('MyBundle:Main:index.html.twig');
        $response->setETag(md5($response->getContent()));
        $response->setPublic(); // make sure the response is public/cacheable
        $response->isNotModified($this->getRequest());

        return $response;
    }

The `isNotModified()` method compares the `ETag` sent with the `Request` with
the one set on the `Response`. If the two match, the method automatically sets
the `Response` status code to `304 Not Modified`.

---

# The Last-Modified Header (1/2)

According to the HTTP specification, _the Last-Modified header field indicates
the date and time at which the origin server believes the representation was
last modified_.

In other words, the application decides **whether or not the cached content has
been updated** based on whether or not it's been updated since the response was
cached.

---

# The Last-Modified Header (2/2)

    !php
    public function showAction($articleSlug)
    {
        // ...

        $articleDate = new \DateTime($article->getUpdatedAt());
        $authorDate  = new \DateTime($author->getUpdatedAt());

        $date = $authorDate > $articleDate ? $authorDate : $articleDate;

        $response->setLastModified($date);
        // Set response as public. Otherwise it will be private by default
        $response->setPublic();

        if ($response->isNotModified($this->getRequest())) {
            return $response;
        }

        // ... do more work to populate the response
        // with the full content

        return $response;
    }

---

# Edge Side Includes (ESI)

**E**dge **S**ide **I**ncludes or ESI is a **small markup language** for dynamic
web content assembly at the reverse proxy level. The reverse proxy analyses the
HTML code, parses ESI specific markup and assembles the final result before
flushing it to the client.

![](https://www.varnish-software.com/static/book/_images/esi.png)

    !html
    <esi:include src="user.php" />
